[{"title":"Leecode 双周赛周六晚 6061.买钢笔和铅笔的方案数","url":"/2022/04/18/Leecode-双周赛周六晚-6061.买钢笔和铅笔的方案数/","content":"\n\n\n\n\n**### 解题思路**\n\n![image.png](https://pic.leetcode-cn.com/1650241045-oobFFd-image.png)\n\n\n\n![image.png](https://pic.leetcode-cn.com/1650241004-XffYKz-image.png)\n\n思路其实就是模拟任意一种情况，比如买一只钢笔，剩下的钱全部买铅笔能买哪几种，不管是哪一种都要考虑到可能买0个这种，所以需要+1，其实这题思路类似不用乘法除法等等实现乘法功能。\n\n![image.png](https://pic.leetcode-cn.com/1650241167-VbwDXN-image.png)\n\n思路上和该题很像\n\n\\```java\n\nclass Solution {\n\n  public int multiply(int A, int B){\n\n  if(B==0)\n\n​    return 0;\n\n  return A+multiply(A,B-1);\n\n}\n\n}\n\n\\```\n\n\n\n以下为买钢笔铅笔的答案\n\n**### 代码**\n\n\n\n\\```java\n\nclass Solution {\n\n  public long waysToBuyPensPencils(int total, int cost1, int cost2) {\n\n​    // 极端案例:[0,0]\n\n​    if(total < cost1 && total < cost2) return 1L;\n\n​    \n\n​    long res = 0;\n\n​    // 以第一种笔数目为基础[0,max1]\n\n​    int max1 = total / cost1;\n\n​    for(int i=0;i<=max1;i++){\n\n​      res+=(total-cost1*i)/cost2+1;\n\n​    }\n\n​    return res;\n\n  }\n\n}\n\n\\```"},{"title":"Leecode 15.三数之和","url":"/2022/04/17/Leecode-15.三数之和/","content":"\n\n\n 因为是经常碰见的题，所以做一下记录，不是一个难题。\n\n\n\n![img](https://img-blog.csdnimg.cn/8781a3c6fe2048cc93517182d21b7110.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_16,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n\n\n```\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n     if(nums.length==0){\n         return new ArrayList(0);\n     }\n     int len=nums.length;\n     List<List<Integer>> lists=new ArrayList();\n//首先将数字排序，这点很关键，排序后我们才能更好的选择我们要的数字\n     Arrays.sort(nums);\n     for(int i=0;i<len;i++){\n        //关于这点，可以等看完下面代码回头看，直接看可能不好理解\n        //其实就是如果我们选择的第一数字已经比0大了。那代表我们不可能在找到和为0的list了，所以就可以直接返回了。\n            if(nums[i]>0){\n             return lists;\n         }\n//如果第i个和i-1个相同就直接跳过，因为题目中说了不要相同的。\n         if(i>0&&nums[i]==nums[i-1]){\n              continue;\n         }   \n         int mid=i+1;\n         int right=len-1;\n//其实这里就是我们去选择第i+1个和len-1个加上第i个，如果是0就添加到数组中，否则继续遍历\n         while(mid<right){\n             if(nums[i]+nums[mid]+nums[right]==0){\n                 lists.add(Arrays.asList(nums[i],nums[mid],nums[right]));\n                  while(mid<right){\n                 if(nums[mid]==nums[mid+1]){\n                     mid=mid+1;\n                 }else \n                    break; \n             }\n            while(mid<right){\n                 if(nums[right]==nums[right-1]){\n                     right=right-1;\n                 }else \n                 break;\n             }\n               mid++;\n            right--;\n             }else if(nums[i]+nums[mid]+nums[right]>0){\n                 right--;\n             }else{\n                 mid++;\n             }   \n            \n         }\n     }\n\n  return lists;\n      }\n \n     }\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n> 其实这题的主要思路就是对每一个当前的数字nums[i]都进行一次i后的遍历。"},{"title":"HTTPS CONTENT","url":"/2022/04/17/HTTPS详解/","content":"\n\n\n\n\n\n\n\n\n HTTPS详解\n\nHTTPS主要是为了解决在http协议中的问题，针对http协议中的三个问题进行优化。\n\n![img](https://img-blog.csdnimg.cn/5c185650c5e841e5a7f19ef66ee32df8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_14,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n以下为HTTPS的具体优化以及流程\n\n<img src=\"https://img-blog.csdnimg.cn/52f4b24be80445beb1197b3f257f3268.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"img\" style=\"zoom:200%;\" />![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\nhttp://assets.processon.com/chart_image/624ad1a97d9c080724790451.png\n"}]