[{"title":"JWT技术应用","url":"/2022/05/19/JWT技术应用/","content":"\n\n\n1.1 组成\n一个token分3部分，按顺序为\n\n头部（header)\n载荷（payload)\n签证（signature)\n三部分之间用.号做分隔。例如：\n\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIxYzdiY2IzMS02ODFlLTRlZGYtYmU3Yy0wOTlkODAzM2VkY2UiLCJleHAiOjE1Njk3Mjc4OTF9.wweMzyB3tSQK34Jmez36MmC5xpUh15Ni3vOV_SGCzJ8\n\n\n1.2 header\nJwt的头部承载两部分信息：\n\n声明类型，这里是Jwt\n声明加密的算法 通常直接使用 HMAC SHA256\nJwt里验证和签名使用的算法列表如下：\n\nJWS\t算法名称\nHS256\tHMAC256\nHS384\tHMAC384\nHS512\tHMAC512\nRS256\tRSA256\nRS384\tRSA384\nRS512\tRSA512\nES256\tECDSA256\nES384\tECDSA384\nES512\tECDSA512\n\n1.3 playload\n载荷就是存放有效信息的地方。基本上填2种类型数据\n\n标准中注册的声明的数据；\n自定义数据。\n由这2部分内部做base64加密。\n\n标准中注册的声明 (建议但不强制使用)\niss: jwt签发者\nsub: jwt所面向的用户\naud: 接收jwt的一方\nexp: jwt的过期时间，这个过期时间必须要大于签发时间\nnbf: 定义在什么时间之前，该jwt都是不可用的.\niat: jwt的签发时间\njti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\n自定义数据:存放我们想放在token中存放的key-value值\n\n```java\npublic class JWTUtils {\n\n    private static final String jwtToken = \"123456Mszlu!@#$$\";\n\n    public static String createToken(Long userId){\n        Map<String,Object> claims = new HashMap<>();\n        claims.put(\"userId\",userId);\n        JwtBuilder jwtBuilder = Jwts.builder()\n                .signWith(SignatureAlgorithm.HS256, jwtToken) // 签发算法，秘钥为jwtToken\n                .setClaims(claims) // body数据，要唯一，自行设置\n                .setIssuedAt(new Date()) // 设置签发时间\n                .setExpiration(new Date(System.currentTimeMillis() + 24  * 60 * 60 * 1000));// 一天的有效时间\n        String token = jwtBuilder.compact();\n        return token;\n    }\n\n    public static Map<String, Object> checkToken(String token){\n        try {\n            Jwt parse = Jwts.parser().setSigningKey(jwtToken).parse(token);\n            return (Map<String, Object>) parse.getBody();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        return null;\n\n    }\n\n}\n```\n\n```\n\n@RestController\n@RequestMapping(\"login\")\npublic class LoginController {\n    @Autowired\n    private LoginService loginService;\n\n    @PostMapping\n    public Result login(@RequestBody loginParams loginp){\n        return loginService.login(loginp);\n    }\n\n}\n\n\n\n//loginParams类        与前端交互的对象 从RequestBody中获取\n@Data\npublic class loginParams {\n private  String account;\n private  String password;\n private  String nickname;\n}\n\n```\n\n```\npublic interface LoginService {\n    Result login(loginParams loginp);\n\n    SysUser checkToken(String token);\n}\n\n```\n\n```\n@Service\n@Transactional\npublic class LoginServiceImpl implements LoginService {\n    @Autowired\n    //注入用户服务\n    private SysUserService sysUserService;  \n    @Autowired\n    //注入Redis\n    private RedisTemplate<String,String> redisTemplate;\n    //加密盐，这里采用固定的加密盐，也可以动态改变\n    private  static final String slat=\"mszlu!@#\";\n\n    @Override\n    public Result login(loginParams loginp) {\n        //检查参数是否合法\n        //看用户名和密码查询  如果存在使用jwt生成token返回给前端，token放入redi中 redis token：user信息设置过期时间\n        //登录认证时候先认证token字符串是否合法，去认证redis是否存在\n        String account = loginp.getAccount();\n        String password = loginp.getPassword();\n        password= DigestUtils.md5Hex(password+slat);\n        if (StringUtils.isBlank(account) || StringUtils.isBlank(password)) {\n            return Result.fail(ErrorCode.PARAMS_ERROR.getCode(), ErrorCode.PARAMS_ERROR.getMsg());\n\n        }\n        SysUser sysUser = sysUserService.findUser(account, password);\n        if (sysUser == null) {\n            return Result.fail(ErrorCode.ACCOUNT_PWD_NOT_EXIST.getCode(), ErrorCode.ACCOUNT_PWD_NOT_EXIST.getMsg());\n        }\n        String token = JWTUtils.createToken(sysUser.getId());\n        redisTemplate.opsForValue().set(\"TOKEN_\"+token, JSON.toJSONString(sysUser),1, TimeUnit.DAYS);\n\n        return Result.success(token);\n    }\n\n    @Override\n    public SysUser checkToken(String token) {\n\n        if(StringUtils.isBlank(token)){\n            return null;\n        }\n        Map<String, Object> stringObjectMap = JWTUtils.checkToken(token);\n        if (stringObjectMap==null){\n            return null;\n        }\n        String userJson = redisTemplate.opsForValue().get(\"TOKEN_\" + token);\n        if(StringUtils.isBlank(userJson)){\n            return null;\n        }\n        SysUser sysUser = JSON.parseObject(userJson, SysUser.class);\n        return sysUser;\n    }\n\n```\n\n```\n @Override\n    public SysUser findUser(String account, String pwd) {\n        LambdaQueryWrapper<SysUser> queryWrapper = new LambdaQueryWrapper<>();\n        queryWrapper.eq(SysUser::getAccount,account);\n        queryWrapper.eq(SysUser::getPassword,pwd);\n        queryWrapper.select(SysUser::getId,SysUser::getAccount,SysUser::getAvatar,SysUser::getNickname);\n        queryWrapper.last(\"limit 1\");\n        SysUser sysUser = sysUserMapper.selectOne(queryWrapper);\n        return sysUser;\n    }\n```\n\n"},{"title":"Leecode 47.全排列II","url":"/2022/04/22/Leecode 47.全排列II/","content":"\n\n\n![e7e170ccb8b944dca027c8efa46a3927](\\Leecode 47.全排列II\\e7e170ccb8b944dca027c8efa46a3927.png)\n\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n```\nclass Solution {\n    //存放结果\n    List<List<Integer>> result = new ArrayList<>();\n    //暂存结果\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        boolean[] used = new boolean[nums.length];\n        Arrays.fill(used, false);\n        Arrays.sort(nums);\n        backTrack(nums, used);\n        return result;\n    }\n\n    private void backTrack(int[] nums, boolean[] used) {\n        if (path.size() == nums.length) {\n            result.add(new ArrayList<>(path));\n         \n        }\n        for (int i = 0; i < nums.length; i++) {\n            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过\n            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过\n            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过\n            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {\n                continue;\n            }\n            //如果同⼀树⽀nums[i]没使⽤过开始处理\n            if (used[i] == false) {\n                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树支重复使用\n                path.add(nums[i]);\n                backTrack(nums, used);\n                path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复\n                used[i] = false;//回溯\n            }\n        }\n    }\n}\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)![](./Leecode 47.全排列II/170b52df4bab483689b0610a879e4126.png)\n\n 这里的回溯需要仔细考虑，可以画一个dfs的树状图理解一下。\n\n是一个非常经典的面试题。\n\n"},{"title":"MVCC 多版本并发控制","url":"/2022/04/19/MVCC-多版本并发控制/","content":"\n\n\n- 前提概要\n  - 什么是 MVCC\n  - 什么是当前读和快照读？\n  - 当前读，快照读和 MVCC 的关系\n\n\n\n> MVCC（多版本并发控制）\n>\n> 主要是为了实现对数据库的并发访问，一般用于数据库中。\n>\n> **MVCC** 在 **MySQL InnoDB** 中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读\n\n\n\n什么是当前读和快照读？\n\n> 当前读：顾名思义读的就是当前最新的，为了达到读的是当前的最新的数据，就必须保证读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。所以像 select lock in share mode (`共享锁`), select for update; update; insert; delete (`排他锁`)这些操作都是一种当前读。\n>\n> 快照读：官方概念是不加锁的非阻塞读，快照读的前提条件是非串行级别，如果在串行级别的隔离等级下，每个操作都是排他性的，那么快照读就退化成了当前读。所以像`不加锁`的 select 操作就是快照读。快照读的实现是基于多版本并发控制，即 MVCC ,可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。\n\n**说白了 MVCC 就是为了实现读-写冲突不加锁，而这个读指的就是`快照读`, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现。**\n\n当前读，快照读和MVCC的关系\n\n​                 ![img](https://img-blog.csdnimg.cn/c6a8854b80c14adfb0e3816566cc7bd1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n------\n\n **MVCC 带来的好处是？**\n\n多版本并发控制（MVCC）是一种用来解决`读-写冲突`的**无锁并发控制**，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以 MVCC 可以为数据库解决以下问题\n\n- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能\n- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题\n\n 简而言之，MVCC 就是因为大佬们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以**在数据库中，因为有了 MVCC，所以我们可以形成两个组合：**\n\n- `MVCC + 悲观锁`\n   MVCC解决读写冲突，悲观锁解决写写冲突\n- `MVCC + 乐观锁`\n   MVCC 解决读写冲突，乐观锁解决写写冲突\n\n------\n\n###  MVCC 的实现原理\n\nMVCC 的目的就是多版本并发控制，在数据库中的实现，就是为了解决`读写冲突`，它的实现原理主要是依赖记录中的 **`3个隐式字段`**，**`undo日志`** ，**`Read View`** 来实现的。所以我们先来看看这个三个 point 的概念。\n\n**隐式字段**\n\n每行记录除了我们自定义的字段外，还有数据库隐式定义的`DB_TRX_ID`, `DB_ROLL_PTR`, `DB_ROW_ID`等字段。\n\n- **`DB_TRX_ID`**\n   6 byte，最近修改(`修改/插入`)事务 ID：记录创建这条记录/最后一次修改该记录的事务 ID\n- **`DB_ROLL_PTR`**\n   7 byte，回滚指针，指向这条记录的上一个版本（存储于 rollback segment 里）\n- **`DB_ROW_ID`**\n   6 byte，隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB 会自动以**`DB_ROW_ID`**产生一个聚簇索引\n- 实际存在一个隐藏的flag字段，既记录被更新或删除并不代表真的删除，而是删除 flag 变了。\n\n​                         ![img](https://img-blog.csdnimg.cn/911bc40cd37c45eebae55d0e07d3a549.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n 如上图，**`DB_ROW_ID`** 是数据库默认为该行记录生成的唯一隐式主键，**`DB_TRX_ID`** 是当前操作该记录的事务 ID ,而 **`DB_ROLL_PTR`** 是一个回滚指针，用于配合 undo日志，指向上一个旧版本。\n\n------\n\n**undo日志**\n\nundo log 主要分为两种：\n\n- **insert undo log**\n   代表事务在 **`insert`** 新记录时产生的 **`undo log`**, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃\n- **update undo log**\n   事务在进行 **`update`** 或 **`delete`** 时产生的 **`undo log`** ; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被 **`purge`** 线程统一清除\n\n对 MVCC 有帮助的实质是 **`update undo log` ，`undo log`** 实际上就是存在 **`rollback segment`** 中旧记录链，**它的执行流程如下：**\n\n​           ![img](https://img-blog.csdnimg.cn/4cf97be6b90f47a8ae3f7f99dd042c31.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n​          \n\n​           ![img](https://img-blog.csdnimg.cn/baad437ecf5f40fca02e64e57f838c50.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n\n\n​                  ![img](https://img-blog.csdnimg.cn/7e11cd79f725430585be755efd917829.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n \n\n​             ![img](https://img-blog.csdnimg.cn/f5dbd96f1ab140b1a6511f88a785c024.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n\n\n​                 ![img](https://img-blog.csdnimg.cn/c033d91b796c401dbe238ee0758a2ec4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n 从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log 的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该 undo log 的节点可能是会 purge 线程清除掉，向图中的第一条 insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）\n \n\n------\n\n **Read View 读视图**\n\n 什么是 Read View，说白了 Read View 就是事务进行快照读操作的时候生产的读视图 (Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID (当每个事务开启时，都会被分配一个 ID , 这个 ID 是递增的，所以最新的事务，ID 值越大)\n\n所以我们知道 **`Read View`** 主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个 `Read View` 读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的**`undo log`**里面的某个版本的数据。\n\nRead View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的 **DB_TRX_ID**（即当前事务 ID ）取出来，与系统当前其他活跃事务的 ID 去对比（由 Read View 维护），如果 DB_TRX_ID 跟 Read View 的属性做了某些比较，不符合可见性，那就通过 **DB_ROLL_PTR** 回滚指针去取出 **Undo Log** 中的 **DB_TRX_ID** 再比较，即遍历链表的 **DB_TRX_ID**（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的 **DB_TRX_ID** , 那么这个 **DB_TRX_ID** 所在的旧记录就是当前事务能看见的最新老版本。\n \n\n​               ![img](https://img-blog.csdnimg.cn/0fab48ac04f4449d9c4f22944860e03e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) \n\n 其实用通俗的个人理解语言来讲，你可以把自己想象成一个事务，所谓的**readview**就是当你在那个时刻你能够看到的数据库中的变化和数据库中数据的当前值。\n\n 换句话讲如果假如水果店有三个苹果，一个人打电话和老板说1点10分要买一个苹果，这时1点整你到了水果店要买一个水果，这时你的readview就是你知道有三个苹果，但是不知道1点10分有一个苹果已经被人预定了，所以其实在readview中的比较就是比较执行当前事务的id能够看见前面执行了多少的事务id。"},{"title":"Leecode 双周赛周六晚 6061.买钢笔和铅笔的方案数","url":"/2022/04/18/Leecode-双周赛周六晚-6061.买钢笔和铅笔的方案数/","content":"\n\n\n\n\n**### 解题思路**\n\n\n\n![点击并拖拽以移动](/Leecode-双周赛周六晚-6061.买钢笔和铅笔的方案数/微信图片_20220419142419.png)\n\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/fdbdc31fa963968fbc8da3839577e632.png)\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n思路其实就是模拟任意一种情况，比如买一只钢笔，剩下的钱全部买铅笔能买哪几种，不管是哪一种都要考虑到可能买0个这种，所以需要+1，其实这题思路类似不用乘法除法等等实现乘法功能。\n\n![img](https://img-blog.csdnimg.cn/img_convert/7987c83a701b1620f9fd05aa84333161.png)\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n思路上和该题很像\n\n\\```java\n\nclass Solution {\n\npublic int multiply(int A, int B){\n\nif(B==0)\n\nreturn 0;\n\nreturn A+multiply(A,B-1);\n\n}\n\n}\n\n\\```\n\n\n\n以下为买钢笔铅笔的答案\n\n**### 代码**\n\n\n\n\\```java\n\nclass Solution {\n\npublic long waysToBuyPensPencils(int total, int cost1, int cost2) {\n\n// 极端案例:[0,0]\n\nif(total < cost1 && total < cost2) return 1L;\n\n\n\nlong res = 0;\n\n// 以第一种笔数目为基础[0,max1]\n\nint max1 = total / cost1;\n\nfor(int i=0;i<=max1;i++){\n\nres+=(total-cost1*i)/cost2+1;\n\n}\n\nreturn res;\n\n}\n\n}\n\n\\```"},{"title":"Leecode 15.三数之和","url":"/2022/04/17/Leecode-15.三数之和/","content":"\n\n\n 因为是经常碰见的题，所以做一下记录，不是一个难题。\n\n\n\n![img](https://img-blog.csdnimg.cn/8781a3c6fe2048cc93517182d21b7110.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_16,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n\n\n```\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n     if(nums.length==0){\n         return new ArrayList(0);\n     }\n     int len=nums.length;\n     List<List<Integer>> lists=new ArrayList();\n//首先将数字排序，这点很关键，排序后我们才能更好的选择我们要的数字\n     Arrays.sort(nums);\n     for(int i=0;i<len;i++){\n        //关于这点，可以等看完下面代码回头看，直接看可能不好理解\n        //其实就是如果我们选择的第一数字已经比0大了。那代表我们不可能在找到和为0的list了，所以就可以直接返回了。\n            if(nums[i]>0){\n             return lists;\n         }\n//如果第i个和i-1个相同就直接跳过，因为题目中说了不要相同的。\n         if(i>0&&nums[i]==nums[i-1]){\n              continue;\n         }   \n         int mid=i+1;\n         int right=len-1;\n//其实这里就是我们去选择第i+1个和len-1个加上第i个，如果是0就添加到数组中，否则继续遍历\n         while(mid<right){\n             if(nums[i]+nums[mid]+nums[right]==0){\n                 lists.add(Arrays.asList(nums[i],nums[mid],nums[right]));\n                  while(mid<right){\n                 if(nums[mid]==nums[mid+1]){\n                     mid=mid+1;\n                 }else \n                    break; \n             }\n            while(mid<right){\n                 if(nums[right]==nums[right-1]){\n                     right=right-1;\n                 }else \n                 break;\n             }\n               mid++;\n            right--;\n             }else if(nums[i]+nums[mid]+nums[right]>0){\n                 right--;\n             }else{\n                 mid++;\n             }   \n            \n         }\n     }\n\n  return lists;\n      }\n \n     }\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n> 其实这题的主要思路就是对每一个当前的数字nums[i]都进行一次i后的遍历。"},{"title":"HTTPS CONTENT","url":"/2022/04/17/HTTPS详解/","content":"\n\n\n\n\n\n\n\n\n HTTPS详解\n\nHTTPS主要是为了解决在http协议中的问题，针对http协议中的三个问题进行优化。\n\n![img](https://img-blog.csdnimg.cn/5c185650c5e841e5a7f19ef66ee32df8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_14,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n以下为HTTPS的具体优化以及流程\n\n<img src=\"https://img-blog.csdnimg.cn/52f4b24be80445beb1197b3f257f3268.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhvdXlhbmcwNDE2,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"img\" style=\"zoom:200%;\" />![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\nhttp://assets.processon.com/chart_image/624ad1a97d9c080724790451.png\n"}]